---------------------------------------------------------
1.
??????0X10----- 
---------------------------------------------------------
2.
5
5
---------------------------------------------------------
3. a) 런타임 오류 A클래스에 소멸자에 virtual을 붙인다
---------------------------------------------------------
4. 과연 원하는 동작인가? t3을 바꾸면 t1도 바뀜 내 예상, << 오버로딩 없음
15
---------------------------------------------------------
5.
 
---------------------------------------------------------
6.
---------------------------------------------------------
7.
---------------------------------------------------------
8.55
---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------
1.
---------------------------------------------------------
2. 런타임 에러 Animal 클래스 소멸자가 가상 함수가 아니기 때문에 개체 a의 bird 메모리를 해제할 수 없
---------------------------------------------------------
3. 
---------------------------------------------------------
4. 
// Point.h
// 여기에 Point.h 파일의 내용을 작성하세요
class Point
{
public:
	Point(int x, int y);
	~Point();
private:
	int mX;
	int mY;
};

// Triangle.h
// 여기에 Triangle.h 파일의 내용을 작성하세요
class Triangle
{
	Triangle(const Point a, const Point b, const Point c);
	Triangle(const Triangle& other);
	~Triangle();

	Triangle& operator=(const Triangle& rhs);
private:
	Point* mPoints[3];
};


// Point.cpp
Point::Point(int x, int y)
	: mX(x)
	, mY(y)
{
}

Point::~Point()
{
}

Triangle::Triangle(const Point a, const Point b, const Point c)
{
	mPoint[0] = new Point(a);
	mPoint[1] = new Point(b);
	mPoint[2] = new Point(c);
}

Triangle::~Triangle()
{
	for (size_t i = 0; i < 3; ++i)
	{
		delete mPoint[i];
	}
}

Triangle::Triangle(const Triangle& other)
{
	for (size_t i = 0; i < 3; ++i)
	{
		mPoint[i] = new Point(other.mPoint[i]);
	}
}

Triangle& Triangle::operator=(const Triangle& rhs)
{
	if (this == &rhs)
	{
		return *this;
	}

	for (size_t i = 0; i < 3; ++i)
	{
		delete mPoint[i];
	}

	for (size_t i = 0; i < 3; ++i)
	{
		mPoint[i] = new Point(rhs.other[i]);
	}

	return *this;
}

// Triangle.cpp
// 여기에 Triangle.cpp 파일의 내용을 작성하세요
---------------------------------------------------------
5. 
before: BaNaNa
after : BaNaNa
---------------------------------------------------------
6.
a)
3
2
1

b)
2
-1
---------------------------------------------------------
7. (virtual 필요한듯?) //에 파일 이름도 잘 못 된듯
// Vehicle.h
// 여기에 Vehicle.h 파일의 내용을 작성하세요
class Vehicle
{
	Vehicle(int year);
	virtual ~Vehicle();
private:
	int mYear;
};

// Boat.h
// 여기에 Boat.h 파일의 내용을 작성하세요
#include "Vehicle.h"
class Boat : public Vehicle
{
	Boat(int year, const char* name);
	Boat(const Boat& other);
	~Boat();
	Boat& operator=(const Boat& rhs);
private:
	char* mName;
};

// Vehicle.h
// 여기에 Vehicle.cpp 파일의 내용을 작성하세요
Vehicle::Vehicle(int year)
	: mYear(year)
{
}

Vehicle::~Vehicle()
{
}

// Boat.h
// 여기에 Boat.cpp 파일의 내용을 작성하세요
Boat::Boat(int year, const char* name)
	: Vehicle(year)
{
	const char* pName = name;
	while (*pName++ != '\0')
	{
	}

	--pName;
	
	mName = new char[pName - name + 1];
	memcpy(mName, name, pName - name + 1);
}

Boat::~Boat()
{
	delete[] mName;
}

Boat::Boat(const Boat& other)
	: Vehicle(other)
{
	const char* pName = other.mName;
	while (*pName++ != '\0')
	{
	}

	--pName;

	mName = new char[pName - other.mName + 1];
	memcpy(mName, other.mName, pName - other.mName + 1);
}

Boat& Boat::operator=(const Boat& rhs) ??????????????????????
{
	if (this == &rhs)
	{
		return *this;
	}

	delete[] mName;

	Vehilce::Vehicle(rhs);
	const char* pName = rhs.mName;

	while (*pName++ != '\0')
	{
	}

	--pName;

	mName = new char[pName - rhs.mName + 1];
	memcpy(mName, rhs.mName, pName - rhs.mName + 1);
}

---------------------------------------------------------
8. 만약 답이 런타임 오류가 아니라면 좀 아닌듯
a) 2) 런타임 오류 v1을 
b) ??????????????????????
5
---------------------------------------------------------
9. 
a) 아니오

---------------------------------------------------------
10. ??????????????????????
---------------------------------------------------------


---------------------------------------------------------
---------------------------------------------------------
3. 레퍼런스는 널 대입이 불가능 하고 주소 이동연산이 불가능 하기 때문에 포인터 보다 안전하다
---------------------------------------------------------
4. reinterpret_cast는 전혀 연관이 없는 클래스 끼리 혹은 자료형 끼리도 캐스팅이 가능하기 때문이다
---------------------------------------------------------
5.
a) 기본 생성자, 소멸자, 복사 생성자, 대입 연산자
b) 암시적으로 만들어지는 함수들의 경우 멤버 변수의 값을 그저 대입하기 때문에 클래스 내부에서 동적 할당하는 메모리가 있다면
얕은 복사 문제가 생길 수 있음
---------------------------------------------------------
6. 
같은 지시 다른 동작
개체가 생성될 때 그 개체의 데이터로 개체가 속한 클래스의 모든 가상함수의 주소를 가지는 가상 함수 테이블도 같이 포함되고
이 가상함수 테이블을 통해 실행 중에 어떤 함수를 호출 할지 결정
---------------------------------------------------------
7. static_cast는 캐스팅시 값을 유지하기 때문에 비트 패턴이 바뀔 수 있지만 reinterpret_cast는 캐스팅 시 
비트패턴이 바뀌지 않고 비트패턴을 그대로 가져와 변환하려는 형으로 재해석 하는 캐스팅
---------------------------------------------------------
8. 인라인 키워드는 멤버 함수에도 붙일 수 있기 때문에 범위를 특정 할 수 있고
매크로 함수보다 디버깅이 용이하다
---------------------------------------------------------
9. new로 메모리 할당 시 초기화가 필요한 데이터를 초기화 시켜 줄 수 있고 메모리의 크기를 알아서 할당 해준다.
---------------------------------------------------------
---------------------------------------------------------

